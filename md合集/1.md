# 《基于 MITM 与 Frida 的移动应用数据抓取与动态分析平台》

用 mitmproxy 做流量代理 + Flask 保存与展示会话 → 前端可视化会话、敏感字段高亮 → 一键生成 Frida hook 脚本（模板化）并下载/运行，从抓包到动态 Hook 完成端到端演示。

# 一、名词与角色说明（短而清晰）

- **mitmproxy**：拦截并观察设备/应用发出的 HTTP(S) 请求的代理工具。你在被测设备上配置它为代理，所有流量经它转发、拦截、分析。
- **mitmproxy 插件（脚本）**：运行在 mitmproxy 内的 Python 脚本（例如 `mitm_to_flask.py`），能在每个 HTTP flow 到达时提取信息并做上报或修改。
- **Flask**：Python 的 Web 框架，作为后端提供 REST API，接收 mitm 上报、存储会话、提供会话查询/导出、并触发 Frida/Probe 操作。
- **SQLite**：轻量文件型数据库，后端把每条会话写入 SQLite（方便持久化、查询与导出）。
- **Socket.IO（WebSocket）**：实时通信框架。后端用它把“新会话”“Frida 日志”等实时事件推给浏览器前端，前端订阅并实时显示。
- **前端页面（index.html）**：展示 UI（会话列表、详情、模板、控制台），与后端通过 REST + Socket.IO 交互。
- **Frida**：动态注入/Hook 框架，可把 JS 脚本注入 Android/iOS App 进程，用来打印/修改内存、拦截 API、dump 等。
- **Probe**：后端提供的“探测”功能（例如 `frida-ps` 查进程、或通过脚本查类），用于定位可注入的进程/类。
- **Spawn / Attach**：Frida 的两种注入方式：`spawn` 先启动 target 并注入，`attach`（或 `-n` 名字）是附加到已存在进程。

------

# 二、整体数据流（一步步说清“谁把什么传给谁”）

1. **设备 → mitmproxy（拦截）**
    手机/模拟器把 HTTP(S) 代理指向 mitmproxy。mitmproxy 解密 HTTPS（若已配置证书），并在 `request()` 回调拿到 `flow`。
2. **mitmproxy 插件提取并上报（异步队列）**
    插件（`mitm_to_flask.py`）会：
   - 从 `flow.request` 提取 `time, url, method, headers, body`；
   - 做简单敏感信息检测（正则、base64 检测等），构造 `suspicious` 列表；
   - 把消息放入内存队列 `_queue`（线程安全）；
   - 启动后台 worker（若尚未启动），worker 从队列取项并用 `requests.post(API_URL, json=payload)` 上报到 Flask 的 `/api/sessions`；
   - worker 有重试、退避、并控制发送速率（避免短时间内大量请求压垮后端）。
3. **Flask 接收并落库 + 通知前端**
    后端的 `/api/sessions`（POST）会：
   - 解析 JSON、生成唯一 `id`（UUID）；
   - 保存到 SQLite（字段：id, time, url, method, headers, body, suspicious）；
   - 通过 `socketio.emit("session_new", {...})` 向所有前端广播新会话事件；
   - 返回 201 创建响应。
4. **前端接收实时通知并拉取数据显示**
    前端在打开页面时：
   - 通过 `io()` 建立 Socket.IO 连接（默认与当前页面 origin 连接）；
   - 监听 `session_new`，收到后触发 `loadSessions()` 拉取 `/api/sessions` 列表并更新左侧表格；
   - 当用户点击某行“查看”时，调用 `/api/sessions/<id>` 显示详情（Headers/Body）在右侧。
5. **Frida / Probe 功能**
   - 前端可选择模板或自定义 JS 脚本，然后调用 `/api/generate_frida`（生成脚本文本）或 `/api/run_frida`、`/api/run_frida_custom`（直接运行注入）。
   - Flask 把脚本写入 `frida_out/`，然后用 `subprocess.Popen` 调 `frida` 命令（`-f` 或 `-n`）注入。
   - 读取 Frida 的 stdout/stderr，把每一行通过 `socketio.emit("frida_log", {"pid":pid,"line":...})` 发送给前端，前端在“控制台输出”区域显示。

------

# 三、每个模块的**具体实现细节**（参考你的代码实现）

### 1) mitmproxy 插件（`mitm_to_flask.py`）实现要点

- **队列与 worker**：使用 `collections.deque()` + `threading.Lock()` 来保证线程安全，`ensure_worker_started()` 启动后台线程 `_worker()`。好处：异步上报，不阻塞 mitm 请求处理。
- **Retry & backoff**：使用 `requests.Session()` + `urllib3.Retry` 做短时重试；若仍失败，会按 `MAX_RETRIES` 丢弃并打印日志避免无限占内存。
- **敏感检测**：`detect_sensitive_from_text()` 做手机号、email、base64 简单检测，返回字符串数组写入 `suspicious` 字段。
- **常见错误点**：
  - `API_URL` 必须包含协议 `http://` 或 `https://`。如果写成 `http:/192.168...`（只一个斜杠），`requests` 抛 `Invalid URL 'http:/...'`。
  - `FLASK_API_URL` 环境变量格式要正确（含 `http://` 且两条斜杠）。
  - mitmplugin 会打印错误日志（便于排查）。

### 2) Flask 后端（`app.py`）实现要点

- **DB 初始化**：`init_db()` 创建 `sessions` 表（字段见上）。
- **POST /api/sessions**：接收 JSON，做“headers 解析/normalization”“suspicious 合并（后端也做一次检测）”，然后插入数据库并 `socketio.emit("session_new", {...})`。
- **GET /api/sessions**：返回会话数组，支持 `q` 模糊搜索（`WHERE url LIKE ? OR method LIKE ? OR body LIKE ?`）。
- **SocketIO**：`socketio = SocketIO(app, cors_allowed_origins="*")`，允许跨域（浏览器前端可以在不同 host/port 下连接）。如果你希望高性能或长期连接稳定，建议在生产里安装 `eventlet` 或 `gevent` 并使用它们作为异步驱动。
- **Frida 接口**：
  - `POST /api/generate_frida`：可按模板或会话生成脚本并返回文本（前端可以下载）。
  - `POST /api/run_frida`：生成脚本写入 `frida_out/`，调用 `frida` 命令注入，返回 `pid`。后台使用线程读取进程 stdout/stderr，并通过 `socketio.emit("frida_log", ...)` 实时推送日志。
  - `POST /api/run_frida_custom`：把用户输入的 `script` 写成文件并执行（同上）。
- **安全**：通过 `ADMIN_TOKEN` 环境变量启用保护，关键路由用 `@require_token` 装饰器检查 `X-ADMIN-TOKEN`。
- **常见错误点**：
  - 如果没有 `frida` 命令或 frida 版本不匹配，会返回错误。
  - 如果 `frida-ps` 或 `frida` 执行超时或不可用，要在后端日志查看具体 stderr。

### 3) SQLite 数据结构（你代码里）

```
CREATE TABLE IF NOT EXISTS sessions(
  id TEXT PRIMARY KEY,
  time TEXT,
  url TEXT,
  method TEXT,
  headers TEXT,
  body TEXT,
  suspicious TEXT
)
```

- `headers`、`suspicious` 以 JSON 字符串保存（`ensure_ascii=False` 用于中文友好）。

### 4) 前端（`index.html`）实现要点

- **API_BASE 动态**：`${location.protocol}//${location.host}/api`，这样访问页面时无须硬编码后端 IP。
- **SocketIO**：`const socket = io();`（connect 到当前 origin），监听 `session_new, sessions_cleared, frida_log, frida_started`。
- **降级轮询**：如果 websocket 断开，`setInterval` 每 5s 轮询 `/api/sessions` 保证界面能看到更新（确保在无法建立 socket 情况下仍可工作）。
- **显示逻辑**：`loadSessions()` 拉取 `/api/sessions` 并渲染表格；`viewDetail(id)` 拉 `/api/sessions/<id>` 展示详情；生成/注入 Frida 都是通过 REST 接口。
- **控制台**：`appendConsole()` 在 DOM `<pre id="consoleOutput">` 中追加每行日志（Frida / probe / 后端错误等）。
- **常见问题**：
  - 如果 `/api/sessions` 返回 `[]`（空数组），说明后端 DB 中确实没数据（或 mitm 没把数据成功 POST）。
  - 若 SocketIO 不连通，页面会显示错误条并改为轮询，但不会有实时推送。

------

# 四、典型的交互序列（便于向导师口述）

1. 设备发出 HTTP 请求 → mitmproxy 拦截 (`mitm_to_flask.request(flow)`)。
2. 插件把会话序列化并 `_enqueue(payload)`（内存队列）。
3. worker 线程取出 payload，`POST http://<flask-host>:5000/api/sessions`（带重试）。
4. Flask `/api/sessions` 接收，写进 SQLite，`socketio.emit("session_new", {...})`。
5. 浏览器前端收到 `session_new` 事件，触发 `loadSessions()`，从 `/api/sessions` 拉新数据并在页面上显示会话。
6. 用户点击会话 → `/api/sessions/<id>` → 右侧显示详情。若用户选择注入脚本，前端调用 `/api/run_frida` 或 `/api/run_frida_custom` → 后端写脚本并调用 `frida` 注入 → Frida 输出经后端 `frida_log` 推回前端控制台。

------

# 五、调试清单（当“前端没收到会话”时按序检查）

1. **确认 mitmproxy 插件是否正在运行并捕获到请求**
   - mitmproxy 控制台会打印 `[OK]` 或 `[SUSP]` 行。
   - 在 mitm 日志里查看是否有 `post exception` 或 `post ok` 的信息。
2. **检查 mitm 插件的 `API_URL` 格式**
   - 必须是 `http://192.168.x.x:5000/api/sessions`（注意 `http://`，并且有两个斜杠 `//`）。
   - 你之前出现 `Invalid URL 'http:/192...': No host supplied` 的错误，说明只写了 `http:/`（单斜杠），修正为 `http://...` 即可。
3. **手动用 curl 验证后端**
   - `curl -v http://<flask-host>:5000/api/sessions` 应返回 `[]` 或会话列表。
   - 如果 `GET` 可用但 mitm 仍失败，说明 mitm 的 POST 报错（看 mitm 日志）。
4. **查看后端日志（server_debug.log / 控制台）**
   - 查 `add_session` 是否被调用、是否插入 DB、是否有错误栈。
5. **检查数据库文件**
   - 用 `sqlite3 sessions.db "select count(*) from sessions;"` 或打开 DB，确认是否有数据。
6. **Socket 连接诊断**
   - 在浏览器开发者工具 Console 看 `socket connected` 等日志；若连接不上，检查后端 `socketio.run` 是否在运行并监听正确 host/port，浏览器控制台与后端日志会显示 socket 错误（CORS、transport mismatch、版本不兼容等）。
7. **防火墙 / 网络**
   - 确保 mitm 所在机器能访问 Flask 的 IP:port（使用 `curl` 从 mitm 机器上测试目标 URL）。
8. **Frida/Probe 问题（单独调试）**
   - `frida` 和 `frida-ps` 是否在 PATH 中，`frida --version` 是否可执行。
   - `frida-ps -Uai` 是否能列出设备上的进程。

------

# 六、示例 JSON（便于展示“这个结构是怎样的”）

mitm 插件上报的 payload（示例）：

```
{
  "time":"2025-09-03T12:01:02.345Z",
  "client":"('192.168.10.100', 50324)",
  "method":"POST",
  "url":"https://api.example.com/login",
  "headers":{"Content-Type":"application/json","User-Agent":"okhttp/3.12.1"},
  "body":"{\"username\":\"alice\",\"password\":\"p@ss\"}",
  "suspicious":["password","base64:QWxhZGRpbjpPcGVuU2VzYW1l"]
}
```

Flask 存入 DB 时会把 `headers` 和 `suspicious` 以 JSON 字符串形式保存。

------

# 七、设计/安全考量（给导师说）

- **优点**：解耦 (mitm→queue→worker→Flask)、实时性（SocketIO），可扩展（更多模板/检测规则），低运维成本（Flask + SQLite）。
- **安全风险**：后端直接执行 Frida 注入和接受自定义脚本存在风险（RCE/滥用），已加入 `ADMIN_TOKEN` 校验与脚本大小限制；生产环境要加访问控制、网络隔离和审计。
- **可靠性**：队列 + retry 降低丢失概率；SocketIO 可用 eventlet/uwsgi 提升并发能力。